/*
 * STM32_rcc_ptr.c
 *
 *  Created on: Oct 20, 2025
 *      Author: ANAS
 */


#include <STM32_rcc_ptr.h>


void clock_enable_LSI (void)
{
	rcc_ptr_ptr->CSR |= 1<<0 ;										/// Enable the low speed internal clock
}

void reset_reason_check(volatile uint8_t *reset_reason_ptr)
{
    uint32_t csr = rcc_ptr_ptr->CSR;  								/// Read the reset reason only once

    if (csr & (1 << 29))
        *reset_reason_ptr = INDEPENDENT_WATCHDOG_RESET;

    else if (csr & (1 << 30))
        *reset_reason_ptr = WINDOW_WATCHDOG_RESET;

    else if (csr & (1 << 26))
        *reset_reason_ptr = RESET_BUTTON_RESET;   					// NRST pin

    else if (csr & (1 << 27))
        *reset_reason_ptr = POWER_ON_RESET;       					// normal

    else if (csr & (1 << 25))
        *reset_reason_ptr = BROWN_OUT_RESET;      					// unstable power

    else if (csr & (1 << 28))
        *reset_reason_ptr = SOFTWARE_RESET;       					// NVIC_SystemReset

    else
        *reset_reason_ptr = UNKNOWN_RESET;

    rcc_ptr_ptr->CSR |= (1 << 23);									// Clear all reset flags
}

void clock_init()
{
    // 1) Enable HSI
    rcc_ptr->CR |= (1 << 0);
    while(!(rcc_ptr->CR & (1 << 1)));  // HSI ready

    // 2) Set AHB = APB1 = APB2 = HSI/1
    rcc_ptr->CFGR = 0;

//    // 3) Flash latency = 0 WS (16MHz)
//    FLASH->ACR &= ~0x7;

    // 4) (OPTIONAL) No PLL, keep HSI
    rcc_ptr->CFGR &= ~(3 << 0);

//    // 5) Update system core clock variable if using CMSIS
//    SystemCoreClock = 16000000;
}
